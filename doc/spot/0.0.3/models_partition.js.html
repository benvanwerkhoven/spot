<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>models/partition.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Aggregate.html">Aggregate</a></li><li><a href="Base.html">Base</a></li><li><a href="CategorialRule.html">CategorialRule</a><ul class='methods'><li data-type='method'><a href="CategorialRule.html#.match">match</a></li></ul></li><li><a href="CategorialTransform.html">CategorialTransform</a><ul class='methods'><li data-type='method'><a href="CategorialTransform.html#.transform">transform</a></li></ul></li><li><a href="Chart.html">Chart</a></li><li><a href="ContinuousRule.html">ContinuousRule</a></li><li><a href="ContinuousTransform.html">ContinuousTransform</a><ul class='methods'><li data-type='method'><a href="ContinuousTransform.html#.inverse">inverse</a></li><li data-type='method'><a href="ContinuousTransform.html#.range">range</a></li><li data-type='method'><a href="ContinuousTransform.html#.transform">transform</a></li></ul></li><li><a href="Dataset.html">Dataset</a><ul class='methods'><li data-type='method'><a href="Dataset.html#.extendFacet">extendFacet</a></li><li data-type='method'><a href="Dataset.html#.extendFilter">extendFilter</a></li><li data-type='method'><a href="Dataset.html#.getAllData">getAllData</a></li><li data-type='method'><a href="Dataset.html#.pause">pause</a></li><li data-type='method'><a href="Dataset.html#.play">play</a></li><li data-type='method'><a href="Dataset.html#.sampleDataset">sampleDataset</a></li><li data-type='method'><a href="Dataset.html#.scanData">scanData</a></li></ul></li><li><a href="Facet.html">Facet</a><ul class='methods'><li data-type='method'><a href="Facet.html#.setCategories">setCategories</a></li><li data-type='method'><a href="Facet.html#.setExceedances">setExceedances</a></li><li data-type='method'><a href="Facet.html#.setMinMax">setMinMax</a></li><li data-type='method'><a href="Facet.html#.setPercentiles">setPercentiles</a></li></ul></li><li><a href="Filter.html">Filter</a><ul class='methods'><li data-type='method'><a href="Filter.html#.getData">getData</a></li><li data-type='method'><a href="Filter.html#.initDataFilter">initDataFilter</a></li><li data-type='method'><a href="Filter.html#.releaseDataFilter">releaseDataFilter</a></li><li data-type='method'><a href="Filter.html#.updateDataFilter">updateDataFilter</a></li></ul></li><li><a href="Group.html">Group</a></li><li><a href="Partition.html">Partition</a><ul class='methods'><li data-type='method'><a href="Partition.html#.setGroups">setGroups</a></li></ul></li><li><a href="TimeTransform.html">TimeTransform</a><ul class='methods'><li data-type='method'><a href="TimeTransform.html#.transform">transform</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-client_colors.html">client/colors</a><ul class='methods'><li data-type='method'><a href="module-client_colors.html#.getColor">getColor</a></li></ul></li><li><a href="module-client_dataset-client.html">client/dataset-client</a><ul class='methods'><li data-type='method'><a href="module-client_dataset-client.html#~initDataFilter">initDataFilter</a></li><li data-type='method'><a href="module-client_dataset-client.html#~releaseDataFilter">releaseDataFilter</a></li><li data-type='method'><a href="module-client_dataset-client.html#~sampleDataset">sampleDataset</a></li><li data-type='method'><a href="module-client_dataset-client.html#~scanData">scanData</a></li><li data-type='method'><a href="module-client_dataset-client.html#~setCategories">setCategories</a></li><li data-type='method'><a href="module-client_dataset-client.html#~setExceedances">setExceedances</a></li><li data-type='method'><a href="module-client_dataset-client.html#~setMinMax">setMinMax</a></li><li data-type='method'><a href="module-client_dataset-client.html#~setPercentiles">setPercentiles</a></li><li data-type='method'><a href="module-client_dataset-client.html#~updateDataFilter">updateDataFilter</a></li></ul></li><li><a href="module-client_dataset-server.html">client/dataset-server</a><ul class='methods'><li data-type='method'><a href="module-client_dataset-server.html#~connect">connect</a></li><li data-type='method'><a href="module-client_dataset-server.html#~initDataFilter">initDataFilter</a></li><li data-type='method'><a href="module-client_dataset-server.html#~releaseDataFilter">releaseDataFilter</a></li><li data-type='method'><a href="module-client_dataset-server.html#~scanData">scanData</a></li><li data-type='method'><a href="module-client_dataset-server.html#~setCategories">setCategories</a></li><li data-type='method'><a href="module-client_dataset-server.html#~setExceedances">setExceedances</a></li><li data-type='method'><a href="module-client_dataset-server.html#~setMinMax">setMinMax</a></li><li data-type='method'><a href="module-client_dataset-server.html#~setPercentiles">setPercentiles</a></li><li data-type='method'><a href="module-client_dataset-server.html#~updateDataFilter">updateDataFilter</a></li></ul></li><li><a href="module-client_misval.html">client/misval</a></li><li><a href="module-client_util-crossfilter.html">client/util-crossfilter</a><ul class='methods'><li data-type='method'><a href="module-client_util-crossfilter.html#~baseValueFn">baseValueFn</a></li><li data-type='method'><a href="module-client_util-crossfilter.html#~groupFn">groupFn</a></li><li data-type='method'><a href="module-client_util-crossfilter.html#~reduceFn">reduceFn</a></li><li data-type='method'><a href="module-client_util-crossfilter.html#~valueFn">valueFn</a></li></ul></li><li><a href="module-client_util-selection.html">client/util-selection</a><ul class='methods'><li data-type='method'><a href="module-client_util-selection.html#~updateSelection">updateSelection</a></li></ul></li><li><a href="module-client_view-factory.html">client/view-factory</a><ul class='methods'><li data-type='method'><a href="module-client_view-factory.html#.newView">newView</a></li></ul></li><li><a href="module-client_widget-factory.html">client/widget-factory</a><ul class='methods'><li data-type='method'><a href="module-client_widget-factory.html#.newModel">newModel</a></li></ul></li></ul><h3>Events</h3><ul><li><a href="Filter.html#event:newData">newData</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<div id="main">
    
    <h1 class="page-title">models/partition.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Partition
 *
 * Describes a partitioning of the data, based on the values a Facet can take.
 * @class Partition
 */
var BaseModel = require('./base');
var Groups = require('./group-collection');
var moment = require('moment-timezone');
var app = require('ampersand-app');
var selection = require('../util-selection');

function setTimeResolution (partition) {
  var start = partition.minval;
  var end = partition.maxval;
  var humanized = end.from(start, true).split(' ');
  var units = humanized[humanized.length - 1];

  if (units === 'minute') {
    units = 'seconds';
  } else if (units === 'hour') {
    units = 'minutes';
  } else if (units === 'day') {
    units = 'hours';
  } else if (units === 'week') {
    units = 'days';
  } else if (units === 'month') {
    units = 'days';
  } else if (units === 'year') {
    units = 'months';
  }
  partition.groupingTimeResolution = units;

  var fmt;
  if (units === 'seconds') {
    fmt = 'mm:ss';
  } else if (units === 'minutes') {
    fmt = 'HH:mm';
  } else if (units === 'hours') {
    fmt = 'HH:00';
  } else if (units === 'days') {
    fmt = 'dddd do';
  } else if (units === 'weeks') {
    fmt = 'wo';
  } else if (units === 'months') {
    fmt = 'YY MMM';
  } else if (units === 'years') {
    fmt = 'YYYY';
  }
  partition.groupingTimeFormat = fmt;
}

/*
 * Setup a grouping based on the `partition.minval`, `partition.maxval`,
 * `partition.groupingTimeResolution` and the `partition.groupingTimeFormat`.
 * @param {Partition} partition
 * @memberof! Partition
 */
function setTimeGroups (partition) {
  setTimeResolution(partition);
  var timeStart = partition.minval;
  var timeEnd = partition.maxval;
  var timeStep = partition.groupingTimeResolution;
  var timeFormat = partition.groupingTimeFormat;

  partition.groups.reset();

  var binned, binStart, binEnd;
  var current = timeStart.clone();
  while (current.isBefore(timeEnd)) {
    binned = current.clone().startOf(timeStep);
    binStart = binned.clone();
    binEnd = binned.clone().add(1, timeStep);

    partition.groups.add({
      min: binStart.format(),
      max: binEnd.format(),
      value: binned,
      label: binned.format(timeFormat)
    });

    current.add(1, timeStep);
  }
}

/*
 * Setup a grouping based on the `partition.groupingContinuous`, `partition.minval`,
 * `partition.maxval`, and the `partition.groupingParam`.
 * @memberof! Partition
 * @param {Partition} partition
 */
function setContinuousGroups (partition) {
  var param = partition.groupingParam;
  var x0, x1, size, nbins;

  if (partition.groupFixedN) {
    // A fixed number of equally sized bins
    nbins = param;
    x0 = partition.minval;
    x1 = partition.maxval;
    size = (x1 - x0) / nbins;
  } else if (partition.groupFixedS) {
    // A fixed bin size
    size = param;
    x0 = Math.floor(partition.minval / size) * size;
    x1 = Math.ceil(partition.maxval / size) * size;
    nbins = (x1 - x0) / size;
  } else if (partition.groupFixedSC) {
    // A fixed bin size, centered on 0
    size = param;
    x0 = (Math.floor(partition.minval / size) - 0.5) * size;
    x1 = (Math.ceil(partition.maxval / size) + 0.5) * size;
    nbins = (x1 - x0) / size;
  } else if (partition.groupLog) {
    // Fixed number of logarithmically (base 10) sized bins
    nbins = param;
    x0 = Math.log(partition.minval) / Math.log(10.0);
    x1 = Math.log(partition.maxval) / Math.log(10.0);
    size = (x1 - x0) / nbins;
  }

  // and update partition.groups
  partition.groups.reset();
  delete partition.groups.comparator; // use as-entered ordering

  function unlog (x) {
    return Math.exp(x * Math.log(10));
  }

  var i;
  for (i = 0; i &lt; nbins; i++) {
    var start = x0 + i * size;
    var end = x0 + (i + 1) * size;
    var mid = 0.5 * (start + end);

    if (partition.groupLog) {
      partition.groups.add({
        min: unlog(start),
        max: unlog(end),
        value: unlog(start),
        label: unlog(end).toPrecision(5)
      });
    } else {
      partition.groups.add({
        min: start,
        max: end,
        value: mid,
        label: mid.toPrecision(5)
      });
    }
  }
}

/*
 * Setup a grouping based on the `partition.categorialTransform`
 * @memberof! Partition
 * @param {Partition} partition
 */
function setCategorialGroups (partition) {
  // and update partition.groups
  partition.groups.reset();

  // use as-entered ordering
  delete partition.groups.comparator;

  if (app &amp;&amp; app.me &amp;&amp; app.me.dataset) {
    var facet = app.me.dataset.facets.get(partition.facetId);
    facet.categorialTransform.forEach(function (rule) {
      partition.groups.add({
        value: rule.group,
        label: rule.group,
        count: rule.count
      });
    });
  }
}

/**
 * Setup the partition.groups()
 * @memberof! Partition
 * @param {Partition} partition
 */
function setGroups (partition) {
  var type = partition.type;

  if (type === 'categorial') {
    setCategorialGroups(partition);
  } else if (type === 'continuous') {
    setContinuousGroups(partition);
  } else if (type === 'datetime') {
    setTimeGroups(partition);
  } else {
    console.error('Cannot set groups for partition', partition.getId());
  }
}

module.exports = BaseModel.extend({
  dataTypes: {
    'numberOrMoment': {
      set: function (value) {
        if (value === +value) {
          // allow setting a number
          return {
            val: +value,
            type: 'numberOrMoment'
          };
        } else {
          // allow setting something moment understands
          value = moment(value, moment.ISO_8601);
          if (value.isValid()) {
            return {
              val: value,
              type: 'numberOrMoment'
            };
          }
        }
        return {
          val: value,
          type: typeof value
        };
      },
      compare: function (currentVal, newVal) {
        if (currentVal instanceof moment) {
          return currentVal.isSame(newVal);
        } else {
          return +currentVal === +newVal;
        }
      }
    }
  },
  props: {
    /**
     * Type of this partition:
     *  * `constant`        A constant value of "1" for all data items
     *  * `continuous`      The facet takes on real numbers
     *  * `categorial`      The facet is a string, or an array of strings (for labels and tags)
     *  * `datetime`  The facet is a datetime (using momentjs)
     * Determined by the facet, and automatically set on updateSelection()
     * @memberof! Partition
     * @type {string}
     */
    type: {
      type: 'string',
      required: true,
      default: 'categorial',
      values: ['constant', 'continuous', 'categorial', 'datetime']
    },

    /**
     * The ID of the facet to partition over
     * @memberof! Partition
     * @type {string}
     */
    facetId: 'string',

    /**
     * When part of a partitioning, this deterimines the ordering
     * @memberof! Partition
     * @type {number}
     */
    rank: 'number',

    /**
     * For continuous or datetime Facets, the minimum value. Values lower than this are grouped to 'missing'
     * @memberof! Partition
     * @type {number|moment}
     */
    minval: 'numberOrMoment',

    /**
     * For continuous or datetime Facets, the maximum value. Values higher than this are grouped to 'missing'
     * @memberof! Partition
     * @type {number|moment}
     */
    maxval: 'numberOrMoment',

    /**
     * Extra parameter used in the grouping strategy: either the number of bins, or the bin size.
     * @memberof! Partition
     * @type {number}
     */
    groupingParam: ['number', true, 20],

    /**
     * Grouping strategy:
     *  * `fixedn`  fixed number of bins in the interval [minval, maxval]
     *  * `fixedsc` a fixed binsize, centered on zero
     *  * `fixeds`  a fixed binsize, starting at zero
     *  * `log`     fixed number of bins but on a logarithmic scale
     * Don't use directly but check grouping via the groupFixedN, groupFixedSC,
     * groupFixedS, and groupLog properties
     * @memberof! Partition
     * @type {number}
     */
    groupingContinuous: {
      type: 'string',
      required: true,
      default: 'fixedn',
      values: ['fixedn', 'fixedsc', 'fixeds', 'log']
    },

    /**
     * Time is grouped by truncating; the groupingTimeResolution parameter sets the resolution.
     * See [this table](http://momentjs.com/docs/#/durations/creating/) for accpetable values
     * when using a crossfilter dataset.
     * @memberof! Partition
     * @type {string}
     */
    groupingTimeResolution: ['string', true, 'hours'],

    /**
     * Formatting string for displaying of datetimes
     * @memberof! Partition
     * @type {string}
     */
    groupingTimeFormat: ['string', true, 'hours'],

    /**
     * Depending on the type of partition, this can be an array of the selected groups,
     * or a numberic interval [start, end]
     * @memberof! Partition
     * @type {array}
     */
    // NOTE: for categorial facets, contains group.value
    selected: {
      type: 'array',
      required: true,
      default: function () {
        return [];
      }
    }
  },

  collections: {
    /**
     * The (ordered) set of groups this Partition can take, making up this partition.
     * Used for plotting
     * @memberof! Partition
     * @type {Group[]}
     */
    groups: Groups
  },
  derived: {
    // properties for grouping-continuous
    groupFixedN: {
      deps: ['groupingContinuous'],
      fn: function () {
        return this.groupingContinuous === 'fixedn';
      }
    },
    groupFixedSC: {
      deps: ['groupingContinuous'],
      fn: function () {
        return this.groupingContinuous === 'fixedsc';
      }
    },
    groupFixedS: {
      deps: ['groupingContinuous'],
      fn: function () {
        return this.groupingContinuous === 'fixeds';
      }
    },
    groupLog: {
      deps: ['groupingContinuous'],
      fn: function () {
        return this.groupingContinuous === 'log';
      }
    }
  },
  updateSelection: function (group) {
    selection.updateSelection(this, group);
  },
  filterFunction: function () {
    return selection.filterFunction(this);
  },
  setGroups: function () {
    setGroups(this);
  }
});
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Wed Aug 17 2016 09:42:24 GMT+0200 (CEST) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
