<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>util-crossfilter.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="CategorialRule.html">CategorialRule</a><ul class='methods'><li data-type='method'><a href="CategorialRule.html#.match">match</a></li><li data-type='method'><a href="CategorialRule.html#.transform">transform</a></li></ul></li><li><a href="CategorialTransform.html">CategorialTransform</a></li><li><a href="Chart.html">Chart</a></li><li><a href="ContinuousTransform.html">ContinuousTransform</a><ul class='methods'><li data-type='method'><a href="ContinuousTransform.html#.transform">transform</a></li></ul></li><li><a href="Dataset.html">Dataset</a><ul class='methods'><li data-type='method'><a href="Dataset.html#.extendFacet">extendFacet</a></li><li data-type='method'><a href="Dataset.html#.extendFilters">extendFilters</a></li><li data-type='method'><a href="Dataset.html#.getAllData">getAllData</a></li><li data-type='method'><a href="Dataset.html#.pause">pause</a></li><li data-type='method'><a href="Dataset.html#.play">play</a></li><li data-type='method'><a href="Dataset.html#.scanData">scanData</a></li></ul></li><li><a href="Facet.html">Facet</a><ul class='methods'><li data-type='method'><a href="Facet.html#.sample10">sample10</a></li><li data-type='method'><a href="Facet.html#.setCategories">setCategories</a></li><li data-type='method'><a href="Facet.html#.setExceedances">setExceedances</a></li><li data-type='method'><a href="Facet.html#.setMinMax">setMinMax</a></li><li data-type='method'><a href="Facet.html#.setPercentiles">setPercentiles</a></li></ul></li><li><a href="Filter.html">Filter</a><ul class='methods'><li data-type='method'><a href="Filter.html#.getData">getData</a></li><li data-type='method'><a href="Filter.html#.initDataFilter">initDataFilter</a></li><li data-type='method'><a href="Filter.html#.initSelection">initSelection</a></li><li data-type='method'><a href="Filter.html#.releaseDataFilter">releaseDataFilter</a></li><li data-type='method'><a href="Filter.html#.updateDataFilter">updateDataFilter</a></li></ul></li><li><a href="Group.html">Group</a></li><li><a href="Selection.html">Selection</a><ul class='methods'><li data-type='method'><a href="Selection.html#.reset">reset</a></li><li data-type='method'><a href="Selection.html#.update">update</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-client_colors.html">client/colors</a><ul class='methods'><li data-type='method'><a href="module-client_colors.html#.getColor">getColor</a></li></ul></li><li><a href="module-client_misval.html">client/misval</a></li><li><a href="module-client_util-crossfilter.html">client/util-crossfilter</a><ul class='methods'><li data-type='method'><a href="module-client_util-crossfilter.html#~baseValueFn">baseValueFn</a></li><li data-type='method'><a href="module-client_util-crossfilter.html#~groupFn">groupFn</a></li><li data-type='method'><a href="module-client_util-crossfilter.html#~reduceFn">reduceFn</a></li><li data-type='method'><a href="module-client_util-crossfilter.html#~unpackArray">unpackArray</a></li><li data-type='method'><a href="module-client_util-crossfilter.html#~valueFn">valueFn</a></li></ul></li><li><a href="module-client_util-sql.html">client/util-sql</a><ul class='methods'><li data-type='method'><a href="module-client_util-sql.html#~connect">connect</a></li></ul></li><li><a href="module-client_view-factory.html">client/view-factory</a><ul class='methods'><li data-type='method'><a href="module-client_view-factory.html#.newView">newView</a></li></ul></li><li><a href="module-client_widget-factory.html">client/widget-factory</a><ul class='methods'><li data-type='method'><a href="module-client_widget-factory.html#.newModel">newModel</a></li></ul></li></ul><h3>Events</h3><ul><li><a href="Filter.html#event:newdata">newdata</a></li><li><a href="Filter.html#event:newfacets">newfacets</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<div id="main">
    
    <h1 class="page-title">util-crossfilter.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Utility functions for crossfilter datasets
 * We roughly follow the crossfilter design of dimensions and groups, but we
 * add an extra step to allow transformations on the data
 * This is needed because crossfilter places a few constraints on the dimensions
 * and group operations: dimensions are ordered and one dimensional, and
 * the grouping operation conforms with the dimension ordering
 * 1. a datum is turned into a base value using baseValFn
 * 2. a base value is transformed into a value (possbily using exceedances,
 *     percentiles, category remapping etc.) using valueFn; this value is then
 *     taken as the crossfilter dimension value
 * 3. a value is grouped using groupFn; this corresponds to a crossfilter group
 *
 * @module client/util-crossfilter
 * @see baseValueFn, valueFn, groupFn
 */
var misval = require('./misval');
var moment = require('moment-timezone');
var math = require('mathjs');

/**
 * @typedef {Object} SubgroupValue
 * @property {number} count The count of the number of elements in this subgroup
 * @property {number} sum The sum of all elements in this subgroup
 */

/**
 * @typedef {Object.&lt;string, SubgroupValue>} SubgroupHash
 */

/**
 * @typedef {Object[]} UnpackedGroups
 * @property {string} key The group key
 * @property {SubgroupHash} value Hash containing subgroups
 */

/**
 * crossfilter dimensions are implemented as arrays for categorial facets,
 * to implement multiple labels/tags per datapoint.
 * This can result in quite messy datastructure returned by group.all()
 * This function re-formats the data to be more regular
 * @param {Object[]} groups - Array of crossfilter groups to unpack
 * @param {(string|string[])} groups.key - The group key as a string or array of strings
 * @param {SubgroupHash} groups.value - A hash mapping subgroup keys on subgroup values
 * @returns {UnpackedGroups} newGroups - Unpacked array of groups
 */
function unpackArray (groups) {
  function merge (key, values) {
    Object.keys(values).forEach(function (subgroup) {
      if (newKeys[key]) {
        newKeys[key][subgroup] = newKeys[key][subgroup] || {count: 0, sum: 0};
        newKeys[key][subgroup].count += values[subgroup].count;
        newKeys[key][subgroup].sum += values[subgroup].sum;
      } else {
        newKeys[key] = {};
        newKeys[key][subgroup] = {count: values[subgroup].count, sum: values[subgroup].sum};
      }
    });
  }

  var newKeys = {};
  groups.forEach(function (group) {
    if (group.key instanceof Array) {
      group.key.forEach(function (subkey) {
        merge(subkey, group.value);
      });
    } else {
      merge(group.key, group.value);
    }
  });

  var newGroups = [];
  Object.keys(newKeys).forEach(function (key) {
    newGroups.push({key: key, value: newKeys[key]});
  });

  return newGroups;
}

// TODO: cummulative sums
/**
 * Reduce a SubgroupValue to a single number
 *
 * @callback reduceCB
 * @param {SubgroupValue} d SubgroupValue
 * @returns {number} Reduced value
 */
/**

/**
 * Returns a function that for further reducing the crossfilter group
 * to a single value, depending on sum/count/average settings of facet
 * @param {Facet} facet - The facet for which to create the reduction function
 * @returns {reduceCB} The required reduction function
 */
function reduceFn (facet) {
  if (facet.reduceSum) {
    /**
     * @callback subgroupSum
     * @param {SubgroupValue} d
     * @returns {number} sum
     */
    return function (d) {
      return d.sum;
    };
  } else if (facet.reduceCount) {
    /**
     * @callback subgroupCount
     * @param {SubgroupValue} d
     * @returns {number} count
     */
    return function (d) {
      return d.count;
    };
  } else if (facet.reduceAverage) {
    /**
     * @callback subgroupAverage
     * @param {SubgroupValue} d
     * @returns {number} d.sum/d.count
     */
    return function (d) {
      if (d.count > 0) {
        return d.sum / d.count;
      } else {
        return 0.0;
      }
    };
  } else {
    console.error('Reduction not implemented for this facet', facet);
  }
  return null;
}

// ********************************************************
// Facet transform utility function
// ********************************************************

/**
 * Returns the base value for a datum
 *
 * @callback baseValueCB
 * @param {Object} d Raw data record
 * @returns {Object} base value
 */

/**
 * Base value for given facet
 * @param {Facet} facet
 * @returns {baseValueCB} Base value function for this facet
 */
function baseValueFn (facet) {
  var accessor;
  if (facet.isProperty) {
    // Nested properties can be accessed in javascript via the '.'
    // so we implement it the same way here.
    var path = facet.accessor.split('.');

    if (path.length === 1) {
      // Use a simple direct accessor, as it is probably faster than the more general case
      // and it was implemented already
      accessor = function (d) {
        var value = misval;
        if (d.hasOwnProperty(facet.accessor)) {
          value = d[facet.accessor];
          if (facet.misval.indexOf(value) > -1 || value === null) {
            value = misval;
          }
        }

        if (facet.isCategorial) {
          if (value instanceof Array) {
            return value;
          } else {
            return [value];
          }
        } else if (facet.isContinuous &amp;&amp; value !== misval) {
          return parseFloat(value);
        }
        return value;
      };
    } else {
      // Recursively follow the crumbs to the desired property
      accessor = function (d) {
        var i = 0;
        var value = d;

        for (i = 0; i &lt; path.length; i++) {
          if (value &amp;&amp; value.hasOwnProperty(path[i])) {
            value = value[path[i]];
          } else {
            value = misval;
            break;
          }
        }

        if (facet.misval.indexOf(value) > -1 || value === null) {
          value = misval;
        }
        if (facet.isCategorial) {
          if (value instanceof Array) {
            return value;
          } else {
            return [value];
          }
        } else if (facet.isContinuous) {
          return parseFloat(value);
        }
        return value;
      };
    }
  } else if (facet.isMath) {
    var formula = math.compile(facet.accessor);

    accessor = function (d) {
      try {
        var value = formula.eval(d);
        return value;
      } catch (e) {
        return misval;
      }
    };
  }

  if (facet.isTimeOrDuration) {
    if (facet.isDuration) {
      /**
       * Duration parsing:
       * 1. If no format is given, the string parsed using
       *    the [ISO 8601 standard](https://en.wikipedia.org/wiki/ISO_8601)
       * 2. If a format is given, the string is parsed as float and interpreted in the given units
       **/
      var durationFormat = facet.baseValueTimeFormat;
      if (durationFormat.length === 0) {
        return function (d) {
          var value = accessor(d);
          if (value !== misval) {
            var m;
            m = moment.duration(value);
            return m;
          }
          return misval;
        };
      } else {
        return function (d) {
          var value = accessor(d);
          if (value !== misval) {
            var m;
            m = moment.duration(parseFloat(value), durationFormat);
            return m;
          }
          return misval;
        };
      }
    } else if (facet.isDatetime) {
      /**
       * Time parsing:
       * 1. moment parses the string using the given format, but defaults to
       *    the [ISO 8601 standard](https://en.wikipedia.org/wiki/ISO_8601)
       * 2. Note that if the string contains timezone information, that is parsed too.
       * 3. The time is transformed to requested timezone, defaulting the locale default
       *    when no baseValueTimeZone is set
       **/
      var timeFormat = facet.baseValueTimeFormat;
      var timeZone = facet.baseValueTimeZone;

      // use default ISO 8601 format
      if (timeFormat.length === 0) {
        timeFormat = moment.ISO_8601;
      }

      // use default locale timezone
      if (timeZone.length === 0) {
        timeZone = moment.tz.guess();
      }

      return function (d) {
        var value = accessor(d);
        if (value !== misval) {
          var m;
          m = moment.tz(value, timeFormat, timeZone);
          return m;
        }
        return misval;
      };
    } else {
      console.error('Time base type not supported for facet', facet);
    }
  } else if (facet.isContinuous || facet.isCategorial) {
    return accessor;
  } else {
    console.error('Facet kind not implemented in baseValueFn: ', facet);
  }
}

/**
 * Returns the transformed value from a base value
 *
 * @callback valueCB
 * @param {Object} d Base value
 * @returns {Object} Transformed value
 */

/**
 * Create a function that returns the transformed value for this facet
 * @param {Facet} facet
 * @returns {valueCB} Value function for this facet
 */
function valueFn (facet) {
  if (facet.isConstant) {
    return function () { return '1'; };
  } else if (facet.isContinuous) {
    return continuousValueFn(facet);
  } else if (facet.isCategorial) {
    return categorialValueFn(facet);
  } else if (facet.isTimeOrDuration) {
    return timeValueFn(facet);
  } else {
    console.error('facetValueFn not implemented for facet type: ', facet);
  }
}

function continuousValueFn (facet) {
  // get base value function
  var baseValFn = baseValueFn(facet);

  // do we have a continuous transform?
  if (facet.continuousTransform &amp;&amp; facet.continuousTransform.length > 0) {
    // yes, use it
    return function (d) {
      var val = facet.continuousTransform.transform(baseValFn(d));
      if (isNaN(val) || val === Infinity || val === -Infinity) {
        return misval;
      }
      return val;
    };
  } else {
    // no, just parse numeric value from base value
    return function (d) {
      var val = baseValFn(d);
      if (isNaN(val) || val === Infinity || val === -Infinity) {
        return misval;
      }
      return val;
    };
  }
}

function categorialValueFn (facet) {
  // get base value function
  var baseValFn = baseValueFn(facet);

  if (facet.categorialTransform &amp;&amp; facet.categorialTransform.length > 0) {
    return function (d) {
      var val = baseValFn(d);

      var i;
      for (i = 0; i &lt; val.length; i++) {
        val[i] = facet.categorialTransform.transform(val[i]);
      }

      // sort alphabetically
      val.sort();

      return val;
    };
  } else {
    return function (d) {
      var val = baseValFn(d);

      // sort alphabetically
      val.sort();

      return val;
    };
  }
}

function timeValueFn (facet) {
  // get base value function
  var baseValFn = baseValueFn(facet);
  var durationFormat = facet.transformTimeUnits;
  var referenceTimeZone = facet.transformTimeZone;
  var referenceMoment = null;

  // time zone for conversions etc.
  if (facet.transformTimeZone.length === 0) {
    referenceTimeZone = moment.tz.guess();
  }

  // construct reference time for duration &lt;-> datetime conversion
  if (facet.transformTimeReference.length > 0) {
    referenceMoment = moment.tz(facet.transformTimeReference, referenceTimeZone);
  }

  if (facet.isDatetime) {
    if (referenceMoment) {
      // datetime -> duration
      return function (d) {
        return baseValFn(d).diff(referenceMoment, durationFormat, true);
      };
    } else if (facet.transformTimeZone.length > 0) {
      // change time zone
      return function (d) {
        return baseValFn(d).tz(referenceTimeZone);
      };
    } else if (facet.transformTimeUnits.length > 0) {
      // format as string, and as it is now a categorial type, wrap it in an array
      // Format specification here http://momentjs.com/docs/#/displaying/format/
      var fmt = facet.transformTimeUnits;
      return function (d) {
        return [baseValFn(d).format(fmt)];
      };
    } else {
      // no change
      return function (d) {
        return baseValFn(d);
      };
    }
  } else if (facet.isDuration) {
    if (referenceMoment) {
      // duration -> datetime
      return function (d) {
        var n = referenceMoment.clone();
        return n.add(baseValFn(d));
      };
    } else if (facet.transformTimeUnits.length > 0) {
      // change units
      return function (d) {
        return baseValFn(d).as(durationFormat);
      };
    } else {
      // no change
      return function (d) {
        return baseValFn(d);
      };
    }
  } else {
    console.error('Time type not implemented for facet', facet);
  }
}

/**
 * Returns the grouped value for a transformed value
 *
 * @callback groupCB
 * @param {Object} d Transformed value
 * @returns {Object} Group
 */

/**
 * Create a function that returns the group value for this facet
 * @param {Facet} facet
 * @returns {groupCB} Group function for this facet
 */
function groupFn (facet) {
  if (facet.displayConstant) {
    return function () { return '1'; };
  } else if (facet.displayContinuous) {
    return continuousGroupFn(facet);
  } else if (facet.displayCategorial) {
    return categorialGroupFn(facet);
  } else if (facet.displayDatetime) {
    return timeGroupFn(facet);
  }

  console.error('Group function not implemented for facet', facet);
}

function continuousGroupFn (facet) {
  return function (d) {
    if (d === misval) {
      return d;
    }

    var ngroups = facet.groups.length;
    if (d &lt; facet.groups.models[0].min || d > facet.groups.models[ngroups - 1].max) {
      return misval;
    }

    // bins include their lower bound, but not their upper bound
    var i = 0;
    while (i &lt; ngroups &amp;&amp; d >= facet.groups.models[i].max) {
      i++;
    }
    // special case last bin includes also upperbound d === facet.maxval
    if (i === ngroups) {
      return facet.groups.models[i - 1];
    }
    return facet.groups.models[i].value;
  };
}

function timeGroupFn (facet) {
  // Round the time to the specified resolution
  // see:
  //  http://momentjs.com/docs/#/manipulating/start-of/
  //  http://momentjs.com/docs/#/displaying/as-javascript-date/
  var timeBin = facet.groupingTimeResolution;
  return function (d) {
    if (d === misval) {
      return d;
    }
    var datetime = d.clone();
    return datetime.startOf(timeBin);
  };
}

function categorialGroupFn (facet) {
  // Don't do any grouping; that is done in the step from base value to value.
  // Matching of facet value and group could lead to a different ordering,
  // which is not allowed by crossfilter
  return function (d) {
    return d;
  };
}

module.exports = {
  baseValueFn: baseValueFn,
  valueFn: valueFn,
  groupFn: groupFn,

  unpackArray: unpackArray,
  reduceFn: reduceFn
};
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Tue Jul 26 2016 16:22:41 GMT+0200 (CEST) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
