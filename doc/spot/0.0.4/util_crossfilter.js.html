<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>util/crossfilter.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Aggregate.html">Aggregate</a></li><li><a href="Base.html">Base</a></li><li><a href="CategorialRule.html">CategorialRule</a><ul class='methods'><li data-type='method'><a href="CategorialRule.html#.match">match</a></li></ul></li><li><a href="CategorialTransform.html">CategorialTransform</a><ul class='methods'><li data-type='method'><a href="CategorialTransform.html#..setCategories">.setCategories</a></li><li data-type='method'><a href="CategorialTransform.html#.transform">transform</a></li></ul></li><li><a href="ContinuousTransform.html">ContinuousTransform</a><ul class='methods'><li data-type='method'><a href="ContinuousTransform.html#.inverse">inverse</a></li><li data-type='method'><a href="ContinuousTransform.html#..setExceedances">.setExceedances</a></li><li data-type='method'><a href="ContinuousTransform.html#..setPercentiles">.setPercentiles</a></li><li data-type='method'><a href="ContinuousTransform.html#.transform">transform</a></li></ul></li><li><a href="ControlPoint.html">ControlPoint</a></li><li><a href="Dataset.html">Dataset</a><ul class='methods'><li data-type='method'><a href="Dataset.html#.extendFacet">extendFacet</a></li><li data-type='method'><a href="Dataset.html#.extendFilter">extendFilter</a></li><li data-type='method'><a href="Dataset.html#.getAllData">getAllData</a></li><li data-type='method'><a href="Dataset.html#.pause">pause</a></li><li data-type='method'><a href="Dataset.html#.play">play</a></li><li data-type='method'><a href="Dataset.html#.sampleDataset">sampleDataset</a></li><li data-type='method'><a href="Dataset.html#.scanData">scanData</a></li></ul></li><li><a href="Facet.html">Facet</a></li><li><a href="Filter.html">Filter</a><ul class='methods'><li data-type='method'><a href="Filter.html#.getData">getData</a></li><li data-type='method'><a href="Filter.html#.initDataFilter">initDataFilter</a></li><li data-type='method'><a href="Filter.html#.releaseDataFilter">releaseDataFilter</a></li><li data-type='method'><a href="Filter.html#.updateDataFilter">updateDataFilter</a></li></ul></li><li><a href="Group.html">Group</a></li><li><a href="Partition.html">Partition</a><ul class='methods'><li data-type='method'><a href="Partition.html#.reset">reset</a></li><li data-type='method'><a href="Partition.html#.setGroups">setGroups</a></li></ul></li><li><a href="TimeTransform.html">TimeTransform</a><ul class='methods'><li data-type='method'><a href="TimeTransform.html#..setMinMax">.setMinMax</a></li><li data-type='method'><a href="TimeTransform.html#.transform">transform</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-client_dataset-client.html">client/dataset-client</a><ul class='methods'><li data-type='method'><a href="module-client_dataset-client.html#~initDataFilter">initDataFilter</a></li><li data-type='method'><a href="module-client_dataset-client.html#~releaseDataFilter">releaseDataFilter</a></li><li data-type='method'><a href="module-client_dataset-client.html#~sampleDataset">sampleDataset</a></li><li data-type='method'><a href="module-client_dataset-client.html#~scanData">scanData</a></li><li data-type='method'><a href="module-client_dataset-client.html#~setCategories">setCategories</a></li><li data-type='method'><a href="module-client_dataset-client.html#~setExceedances">setExceedances</a></li><li data-type='method'><a href="module-client_dataset-client.html#~setMinMax">setMinMax</a></li><li data-type='method'><a href="module-client_dataset-client.html#~setPercentiles">setPercentiles</a></li><li data-type='method'><a href="module-client_dataset-client.html#~updateDataFilter">updateDataFilter</a></li></ul></li><li><a href="module-client_dataset-server.html">client/dataset-server</a><ul class='methods'><li data-type='method'><a href="module-client_dataset-server.html#~connect">connect</a></li><li data-type='method'><a href="module-client_dataset-server.html#~initDataFilter">initDataFilter</a></li><li data-type='method'><a href="module-client_dataset-server.html#~releaseDataFilter">releaseDataFilter</a></li><li data-type='method'><a href="module-client_dataset-server.html#~scanData">scanData</a></li><li data-type='method'><a href="module-client_dataset-server.html#~setCategories">setCategories</a></li><li data-type='method'><a href="module-client_dataset-server.html#~setExceedances">setExceedances</a></li><li data-type='method'><a href="module-client_dataset-server.html#~setMinMax">setMinMax</a></li><li data-type='method'><a href="module-client_dataset-server.html#~setPercentiles">setPercentiles</a></li><li data-type='method'><a href="module-client_dataset-server.html#~updateDataFilter">updateDataFilter</a></li></ul></li><li><a href="module-client_misval.html">client/misval</a></li><li><a href="module-client_util-crossfilter.html">client/util-crossfilter</a><ul class='methods'><li data-type='method'><a href="module-client_util-crossfilter.html#~baseValueFn">baseValueFn</a></li><li data-type='method'><a href="module-client_util-crossfilter.html#~groupFn">groupFn</a></li><li data-type='method'><a href="module-client_util-crossfilter.html#~reduceFn">reduceFn</a></li><li data-type='method'><a href="module-client_util-crossfilter.html#~valueFn">valueFn</a></li></ul></li><li><a href="module-client_util-selection.html">client/util-selection</a><ul class='methods'><li data-type='method'><a href="module-client_util-selection.html#~updateSelection">updateSelection</a></li></ul></li></ul><h3>Events</h3><ul><li><a href="Filter.html#event:newData">newData</a></li></ul><h3>Global</h3><ul><li><a href="global.html#getResolution">getResolution</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">util/crossfilter.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Utility functions for crossfilter datasets
 * We roughly follow the crossfilter design of dimensions and groups, but we
 * add an extra step to allow transformations on the data.
 * 1. a datum is turned into a base value using baseValFn;
 * 2. a base value is transformed into a value (possbily using exceedances,
 *    percentiles, category remapping etc.) using valueFn;
 * 3. a value is grouped using groupFn.
 *
 * @module client/util-crossfilter
 * @see baseValueFn, valueFn, groupFn
 */
var misval = require('./misval');
var moment = require('moment-timezone');
var util = require('../util/time');

/**
 * @typedef {Object} SubgroupValue
 * @property {number} count The count of the number of elements in this subgroup
 * @property {number} sum The sum of all elements in this subgroup
 */

// TODO: cummulative sums
/**
 * Reduce a SubgroupValue to a single number
 *
 * @callback reduceCB
 * @param {SubgroupValue} d SubgroupValue
 * @returns {number} Reduced value
 */
/**

/**
 * Returns a function for further reducing the crossfilter group
 * to a single value, depending on sum/count/average settings of
 * the Aggregate class.
 * @param {Aggregate} facet - The Aggregate class for which to create the reduction function
 * @returns {cb} The required reduction function
 */
function reduceFn (aggregate) {
  if (aggregate.doSum) {
    /**
     * @callback subgroupSum
     * @param {SubgroupValue} d
     * @returns {number} sum
     */
    return function (d) {
      if (d === misval || d == null) {
        return misval;
      }
      if (d.count > 0) {
        return d.sum;
      } else {
        return misval;
      }
    };
  } else if (aggregate.doCount) {
    /**
     * @callback subgroupCount
     * @param {SubgroupValue} d
     * @returns {number} count
     */
    return function (d) {
      if (d === misval || d == null) {
        return misval;
      }
      if (d.count > 0) {
        return d.count;
      } else {
        return misval;
      }
    };
  } else if (aggregate.doAverage) {
    /**
     * @callback subgroupAverage
     * @param {SubgroupValue} d
     * @returns {number} d.sum/d.count
     */
    return function (d) {
      if (d === misval || d == null) {
        return misval;
      }

      if (d.count > 0) {
        return d.sum / d.count;
      } else {
        return misval;
      }
    };
  }

  console.error('Operation not implemented for this Aggregate', aggregate);
  return function (d) {
    if (d === misval || d == null) {
      return misval;
    }
    if (d.count > 0) {
      return d.count;
    } else {
      return misval;
    }
  };
}

// ********************************************************
// Facet transform utility function
// ********************************************************

/**
 * Returns the base value for a datum
 *
 * @callback baseValueCB
 * @param {Object} d Raw data record
 * @returns {Object} base value
 */

/**
 * Base value for given facet
 * @param {Facet} facet
 * @returns {baseValueCB} Base value function for this facet
 */
function baseValueFn (facet) {
  var accessor;

  // Array dimensions have a [] appended to the accessor,
  // remove it to get to the actual accessor
  var path = facet.accessor;
  if (path.match(/\[\]$/)) {
    path = path.substring(0, path.length - 2);
  }

  // Nested properties can be accessed in javascript via the '.'
  // so we implement it the same way here.
  path = path.split('.');

  if (path.length === 1) {
    // Use a simple direct accessor, as it is probably faster than the more general case
    // and it was implemented already
    accessor = function (d) {
      var value = misval;
      if (d.hasOwnProperty(path[0])) {
        value = d[path[0]];
        if (facet.misval.indexOf(value) > -1 || value === null) {
          value = misval;
        }
      }

      return value;
    };
  } else {
    // Recursively follow the crumbs to the desired property
    accessor = function (d) {
      var i = 0;
      var value = d;

      for (i = 0; i &lt; path.length; i++) {
        if (value &amp;&amp; value.hasOwnProperty(path[i])) {
          value = value[path[i]];
        } else {
          value = misval;
          break;
        }
      }

      if (facet.misval.indexOf(value) > -1 || value === null) {
        value = misval;
      }
      return value;
    };
  }

  return accessor;
}

function continuousValueFn (facet) {
  // get base value function
  var baseValFn = baseValueFn(facet);

  // do we have a continuous transform?
  if (facet.continuousTransform &amp;&amp; facet.continuousTransform.type !== 'none') {
    // yes, use it
    return function (d) {
      var val = facet.continuousTransform.transform(parseFloat(baseValFn(d)));
      if (isNaN(val) || val === Infinity || val === -Infinity) {
        return misval;
      }
      return val;
    };
  } else {
    // no, just parse numeric value from base value
    return function (d) {
      var val = parseFloat(baseValFn(d));
      if (isNaN(val) || val === Infinity || val === -Infinity) {
        return misval;
      }
      return val;
    };
  }
}

function categorialValueFn (facet) {
  // get base value function
  var baseValFn = baseValueFn(facet);

  if (facet.categorialTransform &amp;&amp; facet.categorialTransform.rules.length > 0) {
    return function (d) {
      var vals = baseValFn(d);
      if (!(vals instanceof Array)) {
        vals = [vals];
      }
      vals.forEach(function (val, i) {
        vals[i] = facet.categorialTransform.transform(val);
      });
      return vals;
    };
  } else {
    return function (d) {
      return baseValFn(d);
    };
  }
}

function timeValueFn (facet) {
  // get base value function
  var baseValFn = baseValueFn(facet);
  var timeTransform = facet.timeTransform;

  if (timeTransform.isDuration) {
    /**
     * Duration parsing:
     * 1. If no format is given, the string parsed using
     *    the [ISO 8601 standard](https://en.wikipedia.org/wiki/ISO_8601)
     * 2. If a format is given, the string is parsed as float and interpreted in the given units
     **/
    var durationFormat = facet.units;
    if (durationFormat) {
      return function (d) {
        var value = baseValFn(d);
        if (value !== misval &amp;&amp; value == +value) { // eslint-disable-line eqeqeq
          var m = moment.duration(parseFloat(value), durationFormat);
          return timeTransform.transform(m);
        }
        return misval;
      };
    } else {
      return function (d) {
        var value = baseValFn(d);
        if (value !== misval) {
          if (typeof value === 'string' &amp;&amp; value[0].toLowerCase() === 'p') {
            var m = moment.duration(value);
            return timeTransform.transform(m);
          }
        }
        return misval;
      };
    }
  } else if (timeTransform.isDatetime) {
    /**
     * Time parsing:
     * 1. moment parses the string using the given format, but defaults to
     *    the [ISO 8601 standard](https://en.wikipedia.org/wiki/ISO_8601)
     * 2. Note that if the string contains timezone information, that is parsed too.
     * 3. The time is transformed to requested timezone, defaulting the locale default
     *    when no zone is set
     **/
    var timeFormat = facet.units;
    var timeZone = timeTransform.zone;

    // use default ISO 8601 format
    if (timeFormat === 'NONE') {
      timeFormat = moment.ISO_8601;
    }

    // use default locale timezone
    if (timeZone === 'NONE') {
      timeZone = moment.tz.guess();
    }

    return function (d) {
      var value = baseValFn(d);
      if (value !== misval) {
        var m = moment.tz(value, timeFormat, timeZone);
        if (m.isValid()) {
          return timeTransform.transform(m);
        }
      }
      return misval;
    };
  }
}

/**
 * Returns the transformed value from a base value
 *
 * @callback valueCB
 * @param {Object} d Base value
 * @returns {Object} Transformed value
 */

/**
 * Create a function that returns the transformed value for this facet
 * @param {Facet} facet
 * @returns {valueCB} Value function for this facet
 */
function valueFn (facet) {
  if (facet.isConstant) {
    return function () { return '1'; };
  } else if (facet.isContinuous) {
    return continuousValueFn(facet);
  } else if (facet.isCategorial) {
    return categorialValueFn(facet);
  } else if (facet.isTimeOrDuration) {
    return timeValueFn(facet);
  } else {
    console.error('facetValueFn not implemented for facet type: ', facet);
  }
}

function continuousGroupFn (partition) {
  return function (d) {
    if (d === misval) {
      return d;
    }

    var ngroups = partition.groups.length;
    if (d &lt; partition.minval || d > partition.maxval) {
      return misval;
    }

    // bins include their lower bound, but not their upper bound
    var i = 0;
    while (i &lt; ngroups &amp;&amp; d >= partition.groups.models[i].max) {
      i++;
    }
    // special case last bin includes also upperbound d === partition.maxval
    if (i === ngroups) {
      return partition.groups.models[i - 1].value;
    }
    return partition.groups.models[i].value;
  };
}

function timeGroupFn (partition) {
  // Round the time to the specified resolution
  // see:
  //  http://momentjs.com/docs/#/manipulating/start-of/
  //  http://momentjs.com/docs/#/displaying/as-javascript-date/
  var timeStep = util.getResolution(partition.minval, partition.maxval);
  return function (d) {
    if (d === misval) {
      return misval;
    }
    if (d.isBefore(partition.minval) || d.isAfter(partition.maxval)) {
      return misval;
    }
    var datetime = d.clone();
    return datetime.startOf(timeStep);
  };
}

function categorialGroupFn (partition) {
  // Don't do any grouping; that is done in the step from base value to value.
  // Matching of facet value and group could lead to a different ordering,
  // which is not allowed by crossfilter
  return function (d) {
    return d;
  };
}

/**
 * Returns the grouped value for a transformed value
 *
 * @callback groupCB
 * @param {Object} d Transformed value
 * @returns {Object} Group
 */

/**
 * Create a function that returns the group value for a partition
 * @param {Partition} partition
 * @returns {cb} Group function for this partition, taking a `Data`
 */
function groupFn (partition) {
  if (partition.isConstant) {
    return function () { return '1'; };
  } else if (partition.isContinuous) {
    return continuousGroupFn(partition);
  } else if (partition.isCategorial) {
    return categorialGroupFn(partition);
  } else if (partition.isDatetime) {
    return timeGroupFn(partition);
  } else {
    console.error('Group function not implemented for partition', partition);
  }
}

module.exports = {
  baseValueFn: baseValueFn,
  valueFn: valueFn,
  groupFn: groupFn,

  reduceFn: reduceFn
};
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.2</a> on Thu Nov 24 2016 11:01:08 GMT+0100 (CET) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
